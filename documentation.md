<!-- markdownlint-disable MD010 -->

# ShellBuilder Documentation

Notes:

ooc = out of context

Java style naming: `PackageName1.PackageName2.ClassName#variableOrFunctionName`

## Additional Reading

For many of the specific details on arguments, xml tags, etc. for ShellBuilder, see [README.md](README.md).

For more general information about RapidWright see the [RapidWright](https://www.rapidwright.io) website.

[JavaDocs](https://www.rapidwright.io/javadoc/index.html) for RapidWright.

Link to [ShellBuilder](https://github.com/brkicisi/ShellBuilder) GitHub.

To generate offline JavaDocs for ShellBuilder

`javadoc -sourcepath <path to ShellBuilder>/ShellBuilder/src -subpackages main -noqualifier java.lang:java.util:java.io -d docs -verbose -windowtitle ShellBuilder > docs.log`

I haven't figured out how to properly link the docs generated by the above command so that it links to other libraries and not just within itself.

## Running ShellBuilder

The main difference between the ShellBuilder workflow and Vivado is the intermediate caching of placed and routed partial designs.

The workflow in mind when this project was being written was

1. Create a design in Vivado

2. Synthesize design
   - Up to here this is your standard Vivado design flow.

3. Write a simple template generator
   - See [Create a Template Generator](#create-a-template-generator)

4. Run the template generator using ShellBuilder
   - See [Create a Template](#create-a-template)

5. Fill in the template
   - See [Fill in a Template](#fill-in-a-template)

6. Run the builder
   - See [Run Builder](#run-builder)

This should output a dcp containing the final placed and routed design. The final design should be the parallel to having run implementation in Vivado.

For the rest of this section I will be describing the method for using ShellBuilder that I have been designing with. There are other ways to use ShellBuilder (different inputs, not using `initial` & `synth`, etc.). Particularly all the stuff with the design wrapper, there are probably other ways to do it, but this seemed simplest to me.

### Create a Template Generator

This step is very similar for each project. The simplest option is to fill in the blanks in the following generator. The `dcp` under `template` should be filled in to point to the design wrapper. The `locs` as well as `iii_dir`, `ooc_dir` and `out_dir` are suggested to make writing paths easier. The `*_dir`s will also be copied into the template. Additionally, `ooc_dir` will be used to [infer ooc dcps](#infering-dcps) and used to shorten any paths that it infers. More details on how this works in [TemplateBuilder & DirectiveWriter](#templatebuilder--directivewriter).

Other options are allowed as specified in [README.md](README.md).

```xml
<?xml version = "1.0"?>
<root>
    <template>
        <header>
            <iii_dir></iii_dir>
            <ooc_dir></ooc_dir>
            <out_dir></out_dir>
        </header>
        <dcp loc = "ooc">synth_1/design_1_wrapper.dcp</dcp>
        <out loc = "out">build_template.dcp</out>
    </template>
</root>
```

Note: Template generators may be included in the same files as shell builders. In this case, all `TemplateBuilder`s will be run then the top `DirectiveBuilder` will be run.

### Create a Template

Pass the template generator you have just written as the xml argument to the ShellBuilder.

See [Command Line](README.md#command-line) for how to run ShellBuilder.

### Fill in a Template

Running ShellBuilder in the previous step will have generated a file that describes the dcp file input as best it can. If `ooc_dir` is also set, then the dcps for basic modules will be guessed at with the assumption that `dcp` points to the design wrapper and `ooc_dir` is set to `<proj_dir>/<proj_name>.runs`.

You must now fill in any missing dcps and it is recommended that you check that the ones that were input are correct. Some of the missing dcps may be from leaf `inst="merge"` that have no internal cells (besides primative leaf cells **????**) and wires. These cells might not have an associated dcp. If they don't, they should instead be given the tag `only_wires`.

You may optionally set a pblock constraint for each `inst="build"` and `inst="merge"`. If this is set, then that hierarchial module of the design will be placed and routed within the pblock.

By the workflow that was tested, you should also add an `initial` and `proj` tag to the highest level header (in the tested workflow that header has the same module_name as the design wrapper) and you should add a `synth` to the next lower header (which builds the design module in the tested workflow). The `initial` and `synth` tags should both be set to the design wrapper (which was used as the `dcp` in the template generator). The `proj` tag should point to the Vivado project file (.xpr).

If your highest level design is not an out of context module, you should add `buffer_inputs` to the highest level header.

You may want to add `hand_placer` to one or more of the headers. This will invoke RapidWright's HandPlacer, a GUI window which allows you to interactively drag around module blocks to determine placement. Otherwise, ShellBuilder's placement algorithm will try to place modules near their (or their submodule's) pblocks (see [Placing Modules](#placing-modules)).

If you want to refresh part of the design (perhaps you want to use HandPlacer where as before you used default placement), there are two places `refresh` can be added. If `refresh` is within a `header`, all submodules that this is a `header` to (sibling `inst`s) will be recursively refreshed. Instead, `refresh` can be added to an `inst="build"` to not refresh submodules, only to go through placement of this `inst` again.

Optionally you may add other parameters specified in [README.md](README.md).

For more details see [TemplateBuilder & DirectiveWriter](#templatebuilder--directivewriter)

### Run Builder

Pass the filled in template you have just written as the xml argument to the ShellBuilder. If you made a mistake or the program doesn't succeed, you can edit the filled in template and try again (there is no need to go back to the generate template step).

See [Command Line](README.md#command-line) for how to run ShellBuilder.

## Code Workflow

This section will describe in more detail how the ShellBuilder code logically works with specific references to classes and functions. It is intended to help someone who is trying to follow along with how the code works while building a design.

Many of the top level functions are directly or indirectly recursive to handle the tree structure of building a hierarchial design.

![Image of ShellBuilder Workflow](shellbuilder_workflow_top.jpg)

For further reference, see source code and/or [generate the JavaDocs](#additional-reading).

### ShellBuilder#start

The top function is [ShellBuilder](src/main/top/ShellBuilder.java)`#start`. It executes the following tasks

1. Parse command line arguments into an `ArgsContainer`.
2. Parse xml file.
   - Stores xml data using 3 main classes
     1. [DirectiveBuilder](src/main/directive/DirectiveBuilder.java): Wrapper to parse and store a set of sibling `Directive`s, a `DirectiveHeader` and a set of `TemplateBuilder`s.
     2. [Directive](src/main/directive/Directive.java): Describes an instruction regarding how to construct the design. Parallels a `inst="merge"` or `inst="build"`. If it is a `inst="build"` then it stores a `DirectiveBuilder` with all its `inst`, `template` and `header` children. If it is a `inst="merge"` then it stores a dcp and other data to merge its stored dcp into the above design. Both times, it also stores the `header` which is a sibling to this `inst`.
     3. [DirectiveHeader](src/main/directive/DirectiveHeader.java): Stores data common to a group of sibling `Directive`s plus a link to the `header` that is a sibling to the parent of this `header`.
   - These classes recurse to form a tree just like the tree in the xml file being parsed.
   - An additional class
     1. [DirectiveWriter](src/main/directive/DirectiveWriter.java)`.TemplateBuilder`: Stores data relating for generating templates
3. Write templates
   - `ShellBuilder#runTemplateBuilder`: Recursively run all `TemplateBuilder`s that were found in the xml file.
4. Write xdc files for each top level `inst`.
   - Generates constraints files (.xdc) from the project (.xpr) for each hierarchial cell.
5. `ShellBuilder#runBuilder`
   - Main worker for building the final dcp

### XDCWriter#writeAllHierXDC

Creates and runs a tcl script to open the provided project file and generate constraints files from the project for each hierarchial cell (ie. for each `inst`).

Requires that a project file was specified.

Recursively searches through a root `Directive` and all descendants. If the constraint file for this `Directive` is not in the cache or the project file is newer than the cached constraints file then add a line to the script to generate the constraint file for that module and create the proper directory in the cache.

Run the script to open the project and write all constraints files to cache.

### TemplateBuilder & DirectiveWriter

Read the input dcp. Expects design wrapper because it has empty cells at the levels where the ooc dcps are.

Starting with the top cell instance of the input design, construct a tree paralleling the cells in the design using a call to constructInst.

`DirectiveWriter#constructInst(EDIFCellInst ci)`: If ci has no contents, construct an object representing an `inst="merge"` (use `ooc_dir` to attempt to infer the ooc dcp). If ci has contents, construct an object representing an `inst="build"` instead.

- This desinction between what is a leaf (ie. merge) and what is a branch (ie. build) seems to work when the input dcp is the design wrapper. It may not work as well for other dcps since they unlike the wrapper are not going to have empty cells everywhere that there is an ooc module waiting to be filled in.
- For reasons including this, the generated file is a guide only and may need to be adjusted as well as filled in.

`DirectiveWriter#constructBuild(EDIFCellInst ci)`: Construct an object representing an `inst="build"`. Construct an object representing a `header` using `constructHeader` and recursively construct objects representing each subcell by calling `constructInst` on each subcell.

`DirectiveWriter#constructHeader(EDIFCellInst ci)`: Construct a simple header just including the module name.

Add a few more details to the top level header.

#### Infering dcps

The infering of dcps is done under the assumption that `ooc_dir` is set to `<proj_dir>/<proj_name>.runs`. Using this, the program looks for all folders in the `ooc_dir` that have a name `*<cell_type_name>*`. For each of these folders it finds the first dcp file inside. The infered dcp is the one with the shortest name (if any dcps are found). This is to try to account for the fact that one cell's name might be a substring of another cell's name.

### ShellBuilder#runBuilder

This method orchestrates the builder workflow following the instructions contained by a `DirectiveBuilder`. It returns a `Merger` which represents a design consisting of a set of ModuleInsts.

If the `DirectiveBuilder` contains an `initial` then the `Merger` is initialized with that. Else the `Merger` is initialized with an empty design (really it is initialized with no design and later is initialized with an empty design when it tries to add a Module to the `Merger`'s design and finds that it hasn't been initialized yet).

Then it runs each `Directive` using [runDirective](#shellbuilderrundirective).

Then it writes the `Merger` design to a dcp and a tcl script is called to place and route the merged design using Vivado. Note that the constraints file generated earlier for this cell is read in by vivado before place and route is run. Note further that due to some errors I was experiencing, if the tcl script exits with an error, it tries to run again but without the constraints.

If the very last `inst` in this `DirectiveBuilder` is a `write` then the placed and routed dcp and edif are copied there (overwriting the unplaced dcp and edif that were written there by runDirective).

### ShellBuilder#runDirective

Executes a single `Directive` based on its `type`.

- `merge`: Call `Merger#merge` to merge the dcp into the `Merger`'s design.
- `write`: Write design in `Merger` to a dcp.
- `build`: Try to [find module in cache](#mergerfindmoduleincache) and check if it is valid and up to date. If not found, recurse by calling [runBuilder](#shellbuilderrunbuilder) to generate the module in cache. Then call `Merger#merge`.

### Design classes

| Class         | Brief description                                                                                                                                 |
| :------------ | :------------------------------------------------------------------------------------------------------------------------------------------------ |
| `Design`      | Represents a design including both logical and physical netlists as well as placement and routing information. Can be read from/written to a dcp. |
| `EDIFNetlist` | Represents a logical netlist.                                                                                                                     |
| `Module`      | Wrapper for a `Design`. Serves as a prototype for `ModuleInst`s.                                                                                  |
| `ModuleInst`  | An instance of a `Module` which can placed into a `Design` (different design from the one represented by this `ModuleInst`).                      |
| `Merger`      | Wrapper for a `Design`. Handles loading `Design`s into `Module`s and inserting instances of those `Modules` into this `Design`.                   |

### Merger#merge

Orchestrates reading a dcp, placing it into the current design and connecting it to the rest of the design.

### Cache

To speed up implementation of a design that is similar, but not the same as the originally implemented design or a design with multiple implementations of the same module, intermediate designs are cached. The cache is always located in [iii_dir](README.md#iiidir-oocdir--outdir).

The structure of the cache is

- `iii_dir`
  - moduleCache
    - module 1
      - [cached dcp](#dcp) (no pblock constraint given)
      - [edif](#edif)
      - [metadata](#metadata)
      - [xdc](#xdc)
      - pblock 1
        - cached dcp
        - edif
        - metadata
        - xdc
      - pblock 2
        - ...
      - ...
    - module 2
      - ...
    - ...

### Merger#findModuleInCache

Find if the correct directory exists in the cache using `iii_dir`, `module_name` or `dcp` and `pblock`. If it doesn't exist, the module is not yet in the cache. Else the dcp in that directory is the candadate cached dcp.

Parse the [metadata](#metadata) file in the same directory and create 2 copies of a set of all the `dependancy`s with their pblocks.

If `synth` or `initial` for the `Directive` does not match the stored value in the metadata, return not found.

If this `Directive` is an `inst="build"`, then for each child `inst` ensure it is in the first dependancy set (if not in set, return not found), remove it from the second set and try to find it in the cache. If any `inst` could not be found in the cache or was newer than the candadate cached dcp representing this `Directive`, return not found.

As an optimization, the cached modules that have been checked and verified are added to a set of visited modules. The module is not rechecked if it is part of the visited set.

Else the `Directive` is an `inst="merge"`. If the `dcp` is newer than the candidate cached dcp, return not found. Remove the cached dcp from the second dependancy set.

If the dependancy set is not empty, return not found because the cached dcp was created using more `ModuleInst`s than are specified under this `Directive`.

### Merger#fetchAndPropModule

If the directive has the tag `only_wires` cache it to handle later.

If not `refresh` (neither in `header` nor in `inst`) then try to [find the module in cache.](#mergerfindmoduleincache).

If not found then call `Merger#placeRouteOOC`. This invokes Vivado with a tcl script to open the dcp associated with this `Directive`, place and route it and write it to the cache.

Initialize a module using the design that was just found/written.

Call `Merger#myMigrateCellsAndSubCells` to merge the logical netlist library of the loaded design into the logical netlist library of the design being merged into.

### Merger#insertOOC



### Merger#connectAll



## File Types

### DCP

Design checkpoints are the main file for passing information between Vivado and RapidWright. See the [RapidWright](https://www.rapidwright.io) website for more.

### EDIF

Edif files represent logical netlists. They may be encrypted or unencrypted.

When Vivado writes a dcp the edif file in the dcp is likely encrypted by default. Vivado can write unencrypted edifs for many IPs using tcl command `write_edif`. RapidWright cannot read encrypted edifs, however, it can read a dcp and an (unencrypted) edif together as a single `Design`.

[DesignUtils](src/main/util/DesignUtils.java)`#safeReadCheckpoint` wraps RapidWright's `Design#readCheckpoint` so that if it fails, it tries again after invoking Vivado with a tcl script to write the edif.

However, not all IPs may be written unencrypted even by Vivado. In the case that a design has some cells that can't be unencrypted then `write_edif` writes as much of the logical netlist unencrypted as it is allowed to and writes the modules that must remain encrypted to separate encrypted files.

Two file extensions are used for edif files. Those that are requested by ShellBuilder with the tcl command `write_edif` or written in a dcp have the extension `.edf`. Those encrypted edifs that are automatically generated for encrypted cells have the extension `.edn`.

Integrating these files back into the design since they cannot be loaded or written to by RapidWright is not implemented yet. See [Encrypted Modules](#encrypted-modules).

### XDC

Xilinx Design Constraints are important for restricting placement of some cells and ...

The xdcs included in a project are not automatically copied into the ooc dcps. To try to ensure that Vivado's placer and router have all the information needed, I use `write_xdc` for each cell that will be built.

### XML Build Directives

For specific details on the tags and attributes used in this file, see [README.md](README.md).

### Metadata

Metadata files in the cache serve the purpose of keeping track of what files were used to construct this cached file.

They track the `synth` and `initial` files (or lack of) in the header of the `Directive` that built this dcp. They also track all the dcps that were merged into this dcp using the tag `dependancy`.

A module is considered changed and will be regenerated if

- `synth` changed
- `initial` changed
- any `dependancy`
  - cannot be found
  - is newer than this dcp
  - is changed (recurse)
- The set of dependancies (and their pblocks) does not match the build specified in the xml

A `refresh` will regenerate a module as will a `refresh` of any of its submodules (by making one of the module's dependancies out of date).

## Ongoing Issues / Future Work

### PBlock selection

In the future, pblock selection should be automated (as should the rest of filling in and running the template). However, this is not possible while there are a bunch of other issues.

### Placing Modules

Currently `ModuleInst` placement is done with a brute force approach. This is very slow.

Placement of `ModuleInst`s is done in `Merger#insertOOC`. The current approach is

1. Find all possible placements.
   - `mi.getAllValidPlacements`
2. Get target site.
   - Find bottom left of pblock if specified; else bottom left of child modules recursively; else (0, 0).
3. Find valid placement closest to target site. Closest is computed using Manhattan distance.
4. Place `ModuleInst` at closest site to target.

Improvements would:

- Try sites in ascending distance from pblock site.
- Stop when closest site is found rather than trying all sites to see if they are valid placements.
- Better understand how the anchor site and placement are related.
  - I am finding the valid site closest to the bottom left of the pblock because that seems to approximately place the `ModuleInst` in the pblock.
- Separate placement from pblock.
  - Currently it places and routes the module in the pblock given and also tries to place it there. If there are multiple instances of the same `Module` they may be able to use the same routing, but need to be placed in different parts of the device. If different pblocks are specified even for the same module, both will be placed and routed.

### Encrypted Modules

For some IPs Vivado cannot write unencrypted [edifs](#edif). Since RapidWright cannot read encrypted edifs, the full logical netlist of a design including encrypted modules cannot be read into RapidWright. Thus when RapidWright writes such a dcp, it is by necessity incomplete.

To rectify this, the following solution is currently being tested (though this solution has not yet been automated as a part of ShellBuilder).

1. Add the following function in tcl scripts that place and route modules containing encrypted submodules.
   - `update_design -cells [get_cells <encrypted_cell_inst>] -from_file <encrypted_edif>.edn`
   - Insert this line for each encrypted submodule.
   - Inser the lines after `open_checkpoint` and before `read_xdc`.

### Catch failed P&R, try again without read_xdc

There have been some instances where not reading the constraints during place and route has allowed it to succeed where it failed when `read_xdc` was invoked. However, this has not been encountered in a design that has fully completed building. So dropping the `read_xdc` command may or may not be a valid strategy if place and route fails. It may just delay problems for later.

However, it is currently implemented in `Merger` to try a second time without `read_xdc` since it has not yet been shown to cause problems.

### ILAs

The code for adding ILAs that was developed in [AddILA](https://github.com/brkicisi/AddILA) can be found in [ILAAdder](src/main/worker/ILAAdder.java).

There is currently no integration of this with the standard ShellBuilder workflow. It is a separate module.

You can currently call it explicitly from command line or hard code it in.

Future work: add a way to insert ilas using same xml directives as ShellBuilder.

### Vivado Version

Currently the Vivado version can be changed from the default version on your machine by hardcoding it in [TCLScript](src/main/tcl/TCLScript.java)#run. Simply change the line

`bash_lines.add("source /cad1/Xilinx/Vivado/2018.1/settings64.sh");`

so that it sources the appropriate Vivado version. Alternatively set `USE_DEFAULT_VIVADO_VERSION` to true (hardcode this, the variable is just above the last run method). This will use the default version of Vivado that is invoked when you type `vivado` at the command line.
